#' Differential centrality between two observed networks
#'
#' @description
#' Compute per-node, per-statistic differences in centrality between two
#' observed networks (reported as \code{group2 - group1}) and assess
#' significance using a null generated by \code{null_ggm()} via either
#' permutation or bootstrap.
#'
#' @param obs_networks A *named* list of length 2 containing two \pkg{igraph}
#'   objects. The names (for example \code{c("healthy", "disease")}) must match
#'   values present in \code{dat[[group_col]]}.
#' @param dat A data frame passed to \code{null_ggm()} to construct the null.
#' @param group_col Character scalar; name of the column in \code{dat} indicating
#'   group labels. Default is \code{"phenotype"}.
#' @param null_networks A list of null networks from \code{null_ggm()}.
#' @param alternative Character; one of \code{"two.sided"}, \code{"greater"},
#'   or \code{"less"} defining the alternative hypothesis.
#' @param inference_method Character; forwarded to \code{null_ggm()} (for example
#'   \code{"D-S_NW_SL"} or \code{"B_NW_SL"}).
#' @param shuffle_method Character; one of \code{"permutation"} or
#'   \code{"bootstrap"} specifying how the null is generated by \code{null_ggm()}.
#' @param shuffle_iter Integer; number of null replicates to generate.
#'   Default is \code{100}.
#' @param balanced Logical; forwarded to \code{null_ggm()}.
#' @param filter Character; one of \code{"pval"}, \code{"fdr"}, or \code{"none"},
#'   forwarded to \code{null_ggm()}.
#' @param threshold Numeric; forwarded to \code{null_ggm()}.
#' @param n_cores Integer or \code{NULL}; forwarded to \code{null_ggm()}.
#' @param seed Optional seed; forwarded to \code{null_ggm()}.
#'
#' @return A \code{data.frame} with rows corresponding to nodes (row names taken
#'   from the centrality matrices) and columns interleaved by statistic:
#'   \itemize{
#'     \item If \code{shuffle_method == "permutation"}: \eqn{p x (2k)} with
#'       columns \code{<stat>_diff}, \code{<stat>_pval}.
#'     \item If \code{shuffle_method == "bootstrap"}: \eqn{p x (3k)} with
#'       columns \code{<stat>_diff}, \code{<stat>_pval}, \code{<stat>_95pct_CI}.
#'       (The CI level is fixed at 95 percent in the current implementation.)
#'   }
#'
#' @import igraph
#' @importFrom stats pnorm qnorm quantile optimize
#' @importFrom magrittr %>%
#' @export

diff_centrality <- function(obs_networks,
                            dat,
                            group_col = "phenotype",
                            null_networks = NULL,
                            alternative = c("two.sided", "greater", "less"),
                            inference_method = c("D-S_NW_SL", "B_NW_SL"),
                            shuffle_method = c("permutation", "bootstrap"),
                            shuffle_iter = 100,
                            balanced = FALSE,
                            filter = c("pval", "fdr", "none"),
                            threshold = 0.05,
                            n_cores =  NULL,
                            seed = NULL){

  ##  input checks
  if (!is.list(obs_networks))
    stop("'obs_networks' must be a list containing two igraph objects.")
  if (is.null(names(obs_networks)) || any(names(obs_networks) == ""))
    stop("'obs_networks' must be a *named* list with non-empty names (e.g., condition names).")
  if (length(obs_networks) != 2)
    stop("'obs_networks' must contain exactly two elements (two networks to compare).")
  if (!all(vapply(obs_networks, igraph::is.igraph, logical(1))))
    stop("All elements of 'obs_networks' must be valid igraph objects.")


  ## parameters
  alternative      <- match.arg(alternative)
  inference_method <- match.arg(inference_method)
  shuffle_method   <- match.arg(shuffle_method)
  filter           <- match.arg(filter)

  group1 <- names(obs_networks)[1]
  group2 <- names(obs_networks)[2]


  ## generate/unwrap nulls
  if (is.null(null_networks)) {
    if (shuffle_iter < 1L) stop("No null replicates provided.")
    if (!is.data.frame(dat))
      stop("'dat' must be a data frame.")
    if (!group_col %in% names(dat))
      stop("'group_col' must be in the column names of 'dat'.")
    if (!all(names(obs_networks) %in% unique(dat[[group_col]])))
      stop("Names in 'obs_networks' must align with unique values in 'group_col' of 'dat'.")
    nn_wrap <- null_ggm(dat = dat,
                        group_col = group_col,
                        inference_method = inference_method,
                        shuffle_method = shuffle_method,
                        shuffle_iter = shuffle_iter,
                        balanced = balanced,
                        filter = filter,
                        threshold = threshold,
                        n_cores = n_cores,
                        seed = seed)
    null_networks <- .get_null_list(nn_wrap)
    rm(nn_wrap)
  } else {
    null_networks <- .get_null_list(null_networks)  # will stop() if invalid
    if (length(null_networks) < 1L) stop("No null replicates provided in 'null_networks'.")
  }


  ## observed statistics (p x k)
  obs_mats <- lapply(obs_networks, centrality, weight=NULL) %>%
    lapply(., function(df){
      return(as.matrix(df))
    })

  # sanity checks on observed matrices
  if (!all(dim(obs_mats[[group1]]) == dim(obs_mats[[group2]])))
    stop("Observed centrality matrices must share identical dimensions.")
  if (!identical(colnames(obs_mats[[group1]]), colnames(obs_mats[[group2]])))
    stop("Observed centrality matrices must have identical column names (statistics).")

  null_mats <- list()
  for(i in seq_len(length(null_networks))){
    # each null_list[[i]] must be a named list with group1 & group2 graphs
    if (!is.list(null_networks[[i]]) || !all(c(group1, group2) %in% names(null_networks[[i]]))) {
      stop(sprintf("null replicate %d is not a named list with '%s' and '%s'.",
                   i, group1, group2))
    }

    null_mats[[i]] <- lapply(null_networks[[i]], centrality, weight=NULL) %>%
      lapply(., function(df){
        return(as.matrix(df))
      })

  }
  rm(null_networks)

  if (shuffle_method == "bootstrap" && shuffle_iter < 10L) {
    warning("bootstrap: shuffle_iter < 10 - BC p-values/CI may be NA; consider using >= 200.")
  }

  if(shuffle_method == "permutation"){
    res <- .perm_test(obs = obs_mats,
                      null_perm = null_mats,
                      group1 = group1,
                      group2 = group2,
                      alternative = alternative)

  }else{
    res <- .boot_test_bc(obs = obs_mats,
                        null_boot = null_mats,
                        group1 = group1,
                        group2 = group2,
                        alternative = alternative)
  }
  rm(null_mats)
  return(res)


}


#' @keywords internal
.perm_test <- function(obs,
                       null_perm,
                       group1 = names(obs)[1],
                       group2 = names(obs)[2],
                       alternative = c("two.sided", "greater", "less")){

  alternative <- match.arg(alternative)

  # basic checks
  if (!is.list(obs) || length(obs) != 2L)
    stop("'obs' must be a list of length 2 containing two group matrices.")

  X1 <- obs[[group1]]
  X2 <- obs[[group2]]

  if (!is.matrix(X1) || !is.matrix(X2))
    stop("Both groups in 'obs' must be numeric matrices.")
  if (!all(dim(X1) == dim(X2)))
    stop("Matrices in 'obs' must have the same dimensions (p x k).")
  if (!is.list(null_perm) || length(null_perm) < 1L)
    stop("'null_perm' must be a non-empty list of permutation replicates.")

  # observed difference
  effect <- X2 - X1
  p <- nrow(X1)
  k <- ncol(X1)
  B <- length(null_perm)
  stats <- colnames(X1)
  subject_symbols <- rownames(X1)

  counts <- matrix(0L, nrow = p, ncol = k,
                   dimnames = list(rownames(X1), colnames(X1)))

  if (alternative == "two.sided") {
    abs_eff <- abs(effect)
    for (b in seq_len(B)) {
      diff_b <- null_perm[[b]][[group2]] - null_perm[[b]][[group1]]
      counts <- counts + (abs(diff_b) >= abs_eff)
    }
  } else if (alternative == "greater") {
    for (b in seq_len(B)) {
      diff_b <- null_perm[[b]][[group2]] - null_perm[[b]][[group1]]
      counts <- counts + (diff_b >= effect)
    }
  } else { # "less"
    for (b in seq_len(B)) {
      diff_b <- null_perm[[b]][[group2]] - null_perm[[b]][[group1]]
      counts <- counts + (diff_b <= effect)
    }
  }

  # add-one correction always TRUE
  pval <- (counts + 1) / (B + 1)

  # build final data frame (p x 2k)
  res <- as.data.frame(matrix(NA_real_, nrow = p, ncol = 2 * k))
  colnames(res) <- as.vector(rbind(paste0(stats, "_diff"),
                                   paste0(stats, "_pval")))
  rownames(res) <- subject_symbols

  # interleave columns
  for (j in seq_len(k)) {
    res[[2*j - 1]] <- effect[, j]
    res[[2*j]]     <- pval[, j]
  }

  return(res)

}


#' @keywords internal
.boot_test_bc <- function(
    obs,
    null_boot,
    group1 = names(obs)[1],
    group2 = names(obs)[2],
    alternative = c("two.sided", "greater", "less"),
    CI = 0.95,
    ci_digits = 4
) {
  alternative <- match.arg(alternative)

  X1 <- obs[[group1]]
  X2 <- obs[[group2]]
  p <- nrow(X1); k <- ncol(X1); B <- length(null_boot)
  stats <- colnames(X1)
  subject_symbols <- rownames(X1)
  ci_label <- paste0(round(CI * 100), "%_CI")

  # Observed effect
  effect <- X2 - X1
  dimnames(effect) <- list(subject_symbols, stats)

  # Bootstrap differences
  diffs <- array(NA_real_, dim = c(p, k, B))
  for (b in seq_len(B)) {
    diffs[, , b] <- null_boot[[b]][[group2]] - null_boot[[b]][[group1]]
  }

  pval_mat <- matrix(NA_real_, nrow = p, ncol = k, dimnames = list(subject_symbols, stats))
  lo_mat   <- matrix(NA_real_, nrow = p, ncol = k, dimnames = list(subject_symbols, stats))
  hi_mat   <- matrix(NA_real_, nrow = p, ncol = k, dimnames = list(subject_symbols, stats))

  bc_quantiles <- function(z0, z_alpha, pi_vec) {
    q1 <- stats::pnorm(2 * z0 + z_alpha)
    q2 <- stats::pnorm(2 * z0 - z_alpha)
    stats::quantile(pi_vec, probs = sort(c(q1, q2)), names = FALSE, type = 7)
  }

  for (j in seq_len(k)) {
    for (i in seq_len(p)) {
      mi <- effect[i, j]
      pi_vec <- diffs[i, j, ]
      pi_vec <- pi_vec[is.finite(pi_vec)]
      if (!is.finite(mi) || length(pi_vec) < 10L) next

      phat_raw <- mean(pi_vec <= mi)
      eps <- 1 / (length(pi_vec) + 1)
      phat <- min(max(phat_raw, eps), 1 - eps)
      z0 <- abs(stats::qnorm(phat)) * sign(-mean(pi_vec - mi))

      obj <- function(zA) {
        q1 <- stats::pnorm(2 * z0 + zA)
        q2 <- stats::pnorm(2 * z0 - zA)
        qs <- stats::quantile(pi_vec, probs = c(q1, q2), names = FALSE, type = 7)
        diff(range(qs))
      }
      zA <- stats::optimize(obj, interval = c(-10, 10))$minimum

      # p-value
      pval_mat[i, j] <- if (alternative == "two.sided") {
        2 * stats::pnorm(-abs(zA))
      } else if (alternative == "greater") {
        1 - stats::pnorm(zA)
      } else {
        stats::pnorm(zA)
      }

      # CI
      if (alternative == "two.sided") {
        alpha <- (1 - CI) / 2
        z_alpha <- stats::qnorm(alpha)
        qs <- bc_quantiles(z0, z_alpha, pi_vec)
        lo_mat[i, j] <- qs[1]; hi_mat[i, j] <- qs[2]
      } else if (alternative == "greater") {
        alpha <- 1 - CI
        z_alpha <- stats::qnorm(alpha)
        qs <- bc_quantiles(z0, z_alpha, pi_vec)
        lo_mat[i, j] <- qs[1]; hi_mat[i, j] <- Inf
      } else {
        alpha <- 1 - CI
        z_alpha <- stats::qnorm(alpha)
        qs <- bc_quantiles(z0, z_alpha, pi_vec)
        lo_mat[i, j] <- -Inf; hi_mat[i, j] <- qs[2]
      }
    }
  }

  make_ci_str <- function(lo, hi) {
    if (is.infinite(lo) && is.finite(hi)) {
      paste0("(-Inf, ", signif(hi, ci_digits), "]")
    } else if (is.finite(lo) && is.infinite(hi)) {
      paste0("[", signif(lo, ci_digits), ", Inf)")
    } else if (is.finite(lo) && is.finite(hi)) {
      paste0("[", signif(lo, ci_digits), ", ", signif(hi, ci_digits), "]")
    } else {
      NA_character_
    }
  }
  ci_df <- as.data.frame(
    lapply(seq_len(k), function(j) mapply(make_ci_str, lo_mat[, j], hi_mat[, j])),
    optional = TRUE, stringsAsFactors = FALSE
  )
  colnames(ci_df) <- paste0(stats, "_", ci_label)

  blocks <- lapply(seq_len(k), function(j) {
    data.frame(
      diff = effect[, j],
      pval = pval_mat[, j],
      CI   = ci_df[[j]],
      check.names = FALSE
    )
  })
  res <- do.call(cbind, blocks)
  colnames(res) <- as.vector(unlist(lapply(stats, function(s)
    paste0(s, c("_diff", "_pval", "_", ci_label))
  )))
  rownames(res) <- subject_symbols

  return(res)
}


#' @keywords internal
.get_null_list <- function(x) {
  # Expect either the wrapper from null_ggm(): list(null_networks = <list>, tag = "null_ggm")
  # or error out (as you requested).
  if (is.list(x) && !is.null(x$tag) && identical(x$tag, "null_ggm") && is.list(x$null_networks)) {
    return(x$null_networks)
  }
  stop("Invalid input for 'null_networks'. It must be the direct output from `null_ggm()`, ",
       "which returns a list with elements `null_networks` and `tag = 'null_ggm'`.")
}
