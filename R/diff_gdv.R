#' GDV distance-based Differential Connectivity Analysis
#'
#' @description
#' Computes per-node Graphlet Degree Vector (GDV) distances between two networks
#' (and optionally signed GDV distances), then assesses one-sided significance
#' against a null distribution generated by [null_ggm()] via either permutation
#' or bootstrap resampling.
#'
#' Specifically, for each node and GDV metric, the observed distance between the
#' two input networks is compared to the null distribution obtained from
#' repeatedly shuffled (or bootstrapped) networks. The p-values are computed as
#' one-sided probabilities \eqn{P(\text{null} \ge \text{observed})}, with an
#' add-one correction applied.
#'
#' - If `sign = FALSE`: returns a p × 2 data frame with columns
#'   `GDV_distance_dist`, `GDV_distance_pval`
#' - If `sign = TRUE`:  returns a p × 4 data frame adding
#'   `signed_GDV_distance_dist`, `signed_GDV_distance_pval`
#'
#' @param obs_networks A **named** list of exactly two [`igraph`][igraph::igraph]
#'   objects corresponding to the two conditions to compare. The list names
#'   (e.g., `"healthy"`, `"disease"`) must match the unique values in `dat[[group_col]]`.
#'
#' @param dat A data frame used to generate the null networks when
#'   `null_networks` is `NULL`. Must include a grouping column defined by
#'   `group_col`.
#'
#' @param group_col Character scalar; the name of the column in `dat` indicating
#'   group labels. Default is `"phenotype"`.
#'
#' @param null_networks Optional; a list returned directly from [null_ggm()],
#'   which has elements `null_networks` (the list of null replicates) and
#'   `tag = "null_ggm"`. When provided, the function will **not regenerate**
#'   null networks, and the argument `shuffle_iter` is ignored.
#'
#' @param sign Logical; whether to also compute signed GDV distances using the
#'   edge attribute `"sign"`. Defaults to `FALSE`. If `TRUE`, both unsigned and
#'   signed GDV distances are computed and tested.
#'
#' @param inference_method Character; the network inference method passed to
#'   [null_ggm()]. One of `"D-S_NW_SL"` or `"B_NW_SL"`. Only used when
#'   `null_networks` is `NULL`.
#'
#' @param shuffle_method Character; resampling method used to generate the null
#'   networks via [null_ggm()]. One of `"permutation"` or `"bootstrap"`.
#'   Ignored if `null_networks` is provided.
#'
#' @param shuffle_iter Integer; number of null replicates to generate when
#'   constructing the null via [null_ggm()]. Default is `100`. Ignored if
#'   `null_networks` is provided.
#'
#' @param balanced Logical; whether to downsample to equal group sizes before
#'   permutation. Forwarded to [null_ggm()] and used only when
#'   `shuffle_method = "permutation"`.
#'
#' @param filter Character; one of `"pval"`, `"fdr"`, or `"none"`, defining
#'   which edge-filtering criterion to use in [null_ggm()]. Default is `"pval"`.
#'
#' @param threshold Numeric; edge inclusion threshold used when
#'   `filter != "none"`. Default is `0.05`.
#'
#' @param n_cores Integer or `NULL`; number of CPU cores used for parallel
#'   computation (both for GDV distance and null generation). Defaults to one
#'   less than available cores if `NULL`.
#'
#' @param seed Optional integer random seed for reproducibility.
#' @return A `data.frame` with rows corresponding to nodes (row names taken
#'   from the network vertex names) and interleaved columns by statistic:
#'   - `*_dist`: observed GDV distance (unsigned or signed)
#'   - `*_pval`: one-sided p-value (P(null ≥ observed))
#'
#' @import igraph
#' @export
diff_gdv <- function(obs_networks,
                     dat,
                     group_col = "phenotype",
                     null_networks = NULL,
                     sign = FALSE,
                     inference_method = c("D-S_NW_SL", "B_NW_SL"),
                     shuffle_method = c("permutation", "bootstrap"),
                     shuffle_iter = 100,
                     balanced = FALSE,
                     filter = c("pval", "fdr", "none"),
                     threshold = 0.05,
                     n_cores =  NULL,
                     seed = NULL) {

  ## input checks (obs)
  if (!is.list(obs_networks))
    stop("'obs_networks' must be a list containing two igraph objects.")
  if (is.null(names(obs_networks)) || any(names(obs_networks) == ""))
    stop("'obs_networks' must be a *named* list with non-empty names.")
  if (length(obs_networks) != 2L)
    stop("'obs_networks' must contain exactly two networks.")
  if (!all(vapply(obs_networks, igraph::is.igraph, logical(1))))
    stop("All elements of 'obs_networks' must be igraph objects.")

  ## maybe unnecessary
  group1 <- names(obs_networks)[1]
  group2 <- names(obs_networks)[2]

  ## parameters (only used if we need to generate nulls)
  inference_method <- match.arg(inference_method)
  shuffle_method   <- match.arg(shuffle_method)
  filter           <- match.arg(filter)

  if (is.null(null_networks)) {

    ## checks for dat only when generating nulls
    if (!is.data.frame(dat))
      stop("'dat' must be a data frame when generating nulls.")
    if (!group_col %in% names(dat))
      stop("'group_col' must be in the column names of 'dat'.")
    if (!all(c(group1, group2) %in% unique(dat[[group_col]])))
      stop("Names in 'obs_networks' must appear in 'dat[[group_col]]'.")
    if (shuffle_iter < 1L) stop("No null replicates provided.")

    nn_wrap <- null_ggm(dat = dat,
                        group_col = group_col,
                        inference_method = inference_method,
                        shuffle_method = shuffle_method,
                        shuffle_iter = shuffle_iter,
                        balanced = balanced,
                        filter = filter,
                        threshold = threshold,
                        n_cores = n_cores,
                        seed = seed)
    null_networks <- .get_null_list(nn_wrap)
    rm(nn_wrap)
  } else {
    null_networks <- .get_null_list(null_networks)  # will stop() if invalid
    if (length(null_networks) < 1L) stop("No null replicates provided in 'null_networks'.")
  }

  ## observed GDV distance matrix (p x 1 or p x 2)
  obs_mat <- .to_gdv_distance_mat(obs_networks, sign = sign, n_cores = n_cores)

  ## null GDV distance matrices
  null_mats <- list()
  for (i in seq_len(length(null_networks))) {
    # each replicate must be a named list with group1 & group2 graphs
    if (!is.list(null_networks[[i]]) ||
        !all(c(group1, group2) %in% names(null_networks[[i]]))) {
      stop(sprintf("null replicate %d is not a named list with '%s' and '%s'.",
                   i, group1, group2))
    }
    null_mats[[i]] <- .to_gdv_distance_mat(paired_networks = null_networks[[i]],
                                           sign = sign,
                                           n_cores = n_cores)
  }

  # sanity: dims/rownames/colnames must match obs
  if (!identical(dim(null_mats[[i]]), dim(obs_mat)) ||
      !identical(rownames(null_mats[[i]]), rownames(obs_mat)) ||
      !identical(colnames(null_mats[[i]]), colnames(obs_mat))) {
    stop(sprintf("null replicate %d GDV matrix does not match observed dimensions/names.", i))
  }

  rm(null_networks)

  ## one-sided p-values: P(null >= observed), add-one correction
  res <- .get_stats(obs_mat, null_mats)

  return(res)




}

#' @keywords internal
.combine_named_vectors <- function(vec1, vec2) {
  if (!is.numeric(vec1) || !is.numeric(vec2))
    stop("Both inputs must be numeric vectors.")
  if (is.null(names(vec1)) || is.null(names(vec2)))
    stop("Both vectors must be named.")
  if (length(vec1) != length(vec2))
    stop("Vectors must have the same length.")
  if (!setequal(names(vec1), names(vec2)))
    stop("Vectors must have the same set of names.")
  vec2 <- vec2[names(vec1)]
  mat <- cbind(vec1, vec2)
  rownames(mat) <- names(vec1)
  colnames(mat) <- c("GDV_distance", "signed_GDV_distance")
  return(mat)
}

#' @keywords internal
.to_gdv_distance_mat <- function(paired_networks,
                                 sign = FALSE,
                                 n_cores = NULL) {
  # paired_networks: named list of length 2 (two igraphs)
  if (!is.list(paired_networks) || length(paired_networks) != 2L)
    stop("'paired_networks' must be a list of two igraphs.")
  if (!all(vapply(paired_networks, igraph::is.igraph, logical(1))))
    stop("All elements of 'paired_networks' must be igraph objects.")

  if (sign) {
    has_sign_attr <- vapply(paired_networks, function(g) {
      igraph::ecount(g) > 0 && "sign" %in% igraph::edge_attr_names(g)
    }, logical(1))
    if (!all(has_sign_attr)) {
      bad_names <- names(paired_networks)[!has_sign_attr]
      stop(sprintf(
        "The following networks either have no edges or lack edge attribute 'sign': %s",
        paste(bad_names, collapse = ", ")
      ))
    }
  }

  # Unsigned GDV distance
  gdvm_list <- lapply(paired_networks, gdvm_gcm,  level="4", include_gcm=FALSE)
  gdv_dist  <- paired_gdv_distance(gdvm_list[[1]], gdvm_list[[2]])  # named numeric vector

  if (sign) {
    signed_gdvm_list <- lapply(paired_networks, signed_gdvm_gcm,  n_cores =  n_cores, include_gcm=FALSE)
    signed_gdv_dist <- paired_gdv_distance(signed_gdvm_list[[1]], signed_gdvm_list[[2]]) # named vector
    mat <- .combine_named_vectors(gdv_dist, signed_gdv_dist)  # p x 2
  } else {
    # p x 1 matrix with rownames from the vector names
    if (is.null(names(gdv_dist)))
      stop("GDV distance vector must be named (node names).")
    mat <- matrix(gdv_dist, ncol = 1L)
    rownames(mat) <- names(gdv_dist)
    colnames(mat) <- "GDV_distance"
  }
  return(mat)
}

#' @keywords internal
.get_stats <- function(obs_mat, null_mats) {
  if (!is.matrix(obs_mat))
    stop("'obs_mat' must be a matrix.")
  if (!is.list(null_mats) || length(null_mats) < 1L)
    stop("'null_mats' must be a non-empty list of matrices.")

  p <- nrow(obs_mat)
  k <- ncol(obs_mat)
  B <- length(null_mats)

  # validate shapes
  for (b in seq_len(B)) {
    if (!is.matrix(null_mats[[b]]) ||
        !identical(dim(null_mats[[b]]), dim(obs_mat)) ||
        !identical(rownames(null_mats[[b]]), rownames(obs_mat)) ||
        !identical(colnames(null_mats[[b]]), colnames(obs_mat))) {
      stop(sprintf("null_mats[[%d]] is incompatible with 'obs_mat'.", b))
    }
  }

  # One-sided: p = P(null >= observed)
  counts <- matrix(0L, nrow = p, ncol = k,
                   dimnames = list(rownames(obs_mat), colnames(obs_mat)))
  for (b in seq_len(B)) {
    counts <- counts + (null_mats[[b]] >= obs_mat)
  }
  pval <- (counts + 1) / (B + 1)

  # Build final df with interleaved columns <stat>_dist, <stat>_pval
  stats <- colnames(obs_mat)
  subject_symbols <- rownames(obs_mat)
  res <- as.data.frame(matrix(NA_real_, nrow = p, ncol = 2 * k))
  colnames(res) <- as.vector(rbind(paste0(stats, ""),
                                   paste0(stats, "_pval")))
  rownames(res) <- subject_symbols

  for (j in seq_len(k)) {
    res[[2 * j - 1]] <- obs_mat[, j]
    res[[2 * j]]     <- pval[, j]
  }
  return(res)
}


#' @keywords internal
.get_null_list <- function(x) {
  # Expect either the wrapper from null_ggm(): list(null_networks = <list>, tag = "null_ggm")
  # or error out (as you requested).
  if (is.list(x) && !is.null(x$tag) && identical(x$tag, "null_ggm") && is.list(x$null_networks)) {
    return(x$null_networks)
  }
  stop("Invalid input for 'null_networks'. It must be the direct output from `null_ggm()`, ",
       "which returns a list with elements `null_networks` and `tag = 'null_ggm'`.")
}














